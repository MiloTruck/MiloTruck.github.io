---
title: "Binary Exploitation Notes"
tags: [Binary Exploitation]
excerpt: "Notes for Binary Exploitation"
layout: single
classes: wide
--- 
## General Notes
**Calling Convention**  
* 64-bit: `rdi, rsi, rdx, rcx, r8, r9`
  
**ret2syscall**
* 64-bit: `rax = 59, rdi = /bin/sh, rsi = 0, rdx = 0`
* 32-bit: `eax = 11, ebx = /bin/sh, ecx = 0, edx = 0`
* [Syscall Table](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md)

**pwntools**

| Item               | Code                                                    |
|--------------------|---------------------------------------------------------|
| Shellcode          | `shellcode = asm(shellcraft.sh())`                      |
| Strings            | `binsh = libc.search('/bin/sh\x00;).next()`             |
| Gadgets            | `gadget = elf.search(asm('pop rdi; ret')).next()`       |
| Address of Section | `data = elf.get_section_by_name('.data').header.sh_addr`|

## ROP Techniques
* [ret2stack](/ret2stack/): Making the stack executable
* [ret2csu](https://www.voidsecurity.in/2013/07/some-gadget-sequence-for-x8664-rop.html?m=1): Lack of gadgets in 64-bit 

## Heap Techniques
* [House of Force](/House-of-Force/): Exploiting Top Chunk header to gain nearly-arbitrary write primitive
* [Fastbin Dupe](/Fastbin-Dupe/): Tricking malloc into returning an already-allocated heap pointer by abusing the fastbin freelist.
* [Unsafe Unlink](/Unsafe-Unlink/): Exploiting free on a corrupted chunk to get arbitrary write.
